<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣1011.在D天内送达包裹的能力</title>
    <url>/2021/04/26/1011-%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>传送带上的包裹必须在 <code>D</code> 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重<span class="number"> 15 </span>就能够在<span class="number"> 5 </span>天内送达所有包裹，如下所示：</span><br><span class="line">第<span class="number"> 1 </span>天：1, 2, 3, 4, 5</span><br><span class="line">第<span class="number"> 2 </span>天：6, 7</span><br><span class="line">第<span class="number"> 3 </span>天：8</span><br><span class="line">第<span class="number"> 4 </span>天：9</span><br><span class="line">第<span class="number"> 5 </span>天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为<span class="number"> 14 </span>的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重<span class="number"> 6 </span>就能够在<span class="number"> 3 </span>天内送达所有包裹，如下所示：</span><br><span class="line">第<span class="number"> 1 </span>天：3, 2</span><br><span class="line">第<span class="number"> 2 </span>天：2, 4</span><br><span class="line">第<span class="number"> 3 </span>天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第<span class="number"> 1 </span>天：1</span><br><span class="line">第<span class="number"> 2 </span>天：2</span><br><span class="line">第<span class="number"> 3 </span>天：3</span><br><span class="line">第<span class="number"> 4 </span>天：1, 1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>&lt;= D &lt;= weights.length &lt;= <span class="number">50000</span></span><br><span class="line"><span class="symbol">1 </span>&lt;= weights[i] &lt;= <span class="number">500</span></span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days">链接</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>二分法</p>
<p>引用用户<a href="https://leetcode-cn.com/u/jiayangwu/">@Celia</a>的<a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/comments/46984">解释</a>：</p>
<blockquote>
<p>二分查找，根据题意，结果一定落在【max(weights), sum(weights）】这个区间之间，因为左端点对应每天一条船，右端点对应只有一条超级大船。 然后利用二分法，每一次循环模拟运货的过程，然后根据需要的天数与 输入 D 的关系来调整区间左右端点。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: <span class="type">List</span>[<span class="built_in">int</span>], D: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        l, r = <span class="built_in">max</span>(weights), <span class="built_in">sum</span>(weights)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.isEnough(weights, D, mid) <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEnough</span>(<span class="params">self, weights, D, load</span>):</span></span><br><span class="line">        curD, curLoad = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> weights:</span><br><span class="line">            <span class="keyword">if</span> curLoad + w &gt; load:</span><br><span class="line">                curLoad = w</span><br><span class="line">                curD += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                curLoad += w</span><br><span class="line">            <span class="keyword">if</span> curD &gt; D: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>C++博客收藏汇总</title>
    <url>/2020/03/01/C-%E5%8D%9A%E5%AE%A2%E6%94%B6%E8%97%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><a href="https://www.cnblogs.com/chenwx-jay/p/inline_cpp.html">c++内联函数解析（inline）</a></p>
<p><a href="https://www.cnblogs.com/msdn1433/p/3569176.html">C++ inline(内联什么时候使用)</a></p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p><a href="https://blog.csdn.net/piaoxuezhong/article/details/54348787">C++中STL用法总结</a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><a href="https://www.cnblogs.com/zhonghuasong/p/5975979.html">C++ STL之vector用法总结</a></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><p><a href="https://blog.csdn.net/a769973411/article/details/80112655">c++ 排列和字典序全排列解析</a></p>
<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><a href="https://blog.csdn.net/yangyangyang20092010/article/details/47863477">C++ Vector 最大 最小值 索引 位置</a></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><a href="https://blog.csdn.net/Ackerman2/article/details/103780911">c++STL库中find()的简单使用示例</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Action 尝鲜</title>
    <url>/2020/03/03/Github-Action-%E5%B0%9D%E9%B2%9C/</url>
    <content><![CDATA[<p>发现GitHub上有个Action功能. 查阅后,感觉它能当成一个远端的服务器用.<br>于是搜寻教程,自动在库 <code>.github/workflows/</code>目录下创建了.yml文件.<br>配置一下这个文件基本就万事大吉了.</p>
<p>主要实现让自己仓库里的文件能在action理运行, 并且让github回传送txt文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Run</span> <span class="string">Python</span> <span class="string">&amp;</span> <span class="string">up</span> <span class="string">.txt</span> <span class="string">file</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="number">3.8</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="number">3.8</span>      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">python</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/Ackermannn/TestAction.git</span></span><br><span class="line">        <span class="string">python</span> <span class="string">hello.py</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Up</span> <span class="string">something</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">path/to/artifact</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">hello</span> <span class="string">&gt;</span> <span class="string">path/to/artifact/world.txt</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v1</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">my-artifact</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">path/to/artifact</span></span><br></pre></td></tr></table></figure>

<p>参考链接:</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">阮一峰的网络日志:GitHub Actions 入门教程</a></p>
<p><a href="https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions">action/setup-python的官方文档</a></p>
<p><a href="https://github.com/actions/upload-artifact">actions/upload-artifact</a></p>
]]></content>
      <tags>
        <tag>Github Action</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>matplotlib画图中文显示的错误</title>
    <url>/2020/04/18/matplotlib%E7%94%BB%E5%9B%BE%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>使用python的matplotlib库画图时，xlabel title 会出现中文无法显示的问题。可以参考一下代码解决问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修补画图时 中文乱码的问题</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql使用速记</title>
    <url>/2020/05/24/postgresql%E4%BD%BF%E7%94%A8%E9%80%9F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基本使用1"><a href="#基本使用1" class="headerlink" title="基本使用1"></a>基本使用<a href="https://www.jianshu.com/p/34afe4072598">1</a></h1><p>登录</p>
<pre><code>psql -U postgres</code></pre><p>创建数据库用户</p>
<pre><code>CREATE USER user_name WITH PASSWORD &apos;password&apos;;</code></pre><p>创建用户数据库</p>
<pre><code>CREATE DATABASE user_name OWNER user_name;</code></pre><p>给予权限</p>
<pre><code>GRANT ALL PRIVILEGES ON DATABASE user_name to user_name;</code></pre><p>删除用户与数据库</p>
<pre><code>DROP DATABASE user_name;
DROP USER user_name;</code></pre><p>控制台命令</p>
<pre><code>\l 列出所有数据库
\d 列出当前数据库的所有表格
\d [table_name] 列出某一张表格的结构
\c [database_name] 切换数据库
\c - [user_name] 切换用户</code></pre><p>查看数据库占用的物理存储空间大小<a href="https://www.cnblogs.com/liuyuanyuanGOGO/p/3224554.html">2</a></p>
<p>sql语句查询：</p>
<pre><code>postgres=# select pg_size_pretty(pg_database_size(&apos;postgres&apos;));

pg_size_pretty
----------------
6229 kB
(1 行记录)</code></pre><h1 id="配置PostgreSQL允许远程连接的方法"><a href="#配置PostgreSQL允许远程连接的方法" class="headerlink" title="配置PostgreSQL允许远程连接的方法"></a>配置PostgreSQL允许远程连接的方法</h1><p><a href="https://blog.csdn.net/u014698745/article/details/86612511?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-6">配置PostgreSQL允许远程连接的方法（PostgreSQL新手入坑）</a></p>
<p>linux 下怎么看postgresql安装到哪个目录了？</p>
<pre><code>psql -U postgres -c &apos;SHOW config_file&apos;</code></pre><p>可参考以下配置文件目录：</p>
<pre><code>sudo vim /var/lib/postgres/data/postgresql.conf
sudo vim /var/lib/postgres/data/pg_hba.conf</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/34afe4072598">https://www.jianshu.com/p/34afe4072598</a></p>
<p><a href="https://www.cnblogs.com/liuyuanyuanGOGO/p/3224554.html">https://www.cnblogs.com/liuyuanyuanGOGO/p/3224554.html</a></p>
<h1 id="踩坑笔记"><a href="#踩坑笔记" class="headerlink" title="踩坑笔记"></a>踩坑笔记</h1><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>如果出现这种情况：</p>
<pre><code>~ &gt;&gt;&gt; psql
psql: error: could not connect to server: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket &quot;/run/postgresql/.s.PGSQL.5432&quot;?</code></pre><p>是根本没启动！！！<br>一个命令可直接启动</p>
<pre><code>sudo systemctl start postgresql.service
sudo systemctl restart postgresql.service</code></pre>]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>python修改工作路径</title>
    <url>/2020/04/18/python%E4%BF%AE%E6%94%B9%E5%B7%A5%E4%BD%9C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="修改工作路径方便测试开发"><a href="#修改工作路径方便测试开发" class="headerlink" title="修改工作路径方便测试开发"></a>修改工作路径方便测试开发</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 修改工作路径方便测试开发</span></span><br><span class="line">path = <span class="string">r&quot;C:\Users\Administrator\Documents\GitHub\BF-grading-range\\&quot;</span></span><br><span class="line">os.chdir(path)  <span class="comment"># 也可 ../ 如此切换路径</span></span><br></pre></td></tr></table></figure>

<p>此外</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.getcwd() <span class="comment"># 查看工作路径</span></span><br></pre></td></tr></table></figure>

<h1 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chdir</span>():</span></span><br><span class="line">    <span class="comment"># 切换工作路径</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    path = <span class="string">&quot;../&quot;</span></span><br><span class="line">    os.chdir(path)</span><br><span class="line">    a = os.getcwd()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chdir()</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/python/os-chdir.html">https://www.runoob.com/python/os-chdir.html</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python创建文件夹</title>
    <url>/2020/04/18/python%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>如果文件夹不存在 创建文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dirs):</span><br><span class="line">    os.makedirs(dirs)</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_39575835/article/details/103974778">https://blog.csdn.net/qq_39575835/article/details/103974778</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python读取pickle,csv,excel文件速度大比拼</title>
    <url>/2021/04/23/python%E8%AF%BB%E5%8F%96pickle-csv-excel%E6%96%87%E4%BB%B6%E9%80%9F%E5%BA%A6%E5%A4%A7%E6%AF%94%E6%8B%BC/</url>
    <content><![CDATA[<p>进行数据处理时数据量一大，excel文件就力不从心。<br>这次对三个文件格式的读取速度做大比拼。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">csv</span></span><br><span class="line"><span class="string">excel</span></span><br><span class="line"><span class="string">pkl</span></span><br><span class="line"><span class="string">速度大比拼</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">start = time.clock()</span><br><span class="line">df = pd.read_pickle(<span class="string">&#x27;table.pkl&#x27;</span>)</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PKL Time used:&quot;</span>, elapsed)</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;table.csv&#x27;</span>)</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;CSV Time used:&quot;</span>, elapsed)</span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;table.xlsx&#x27;</span>)</span><br><span class="line">elapsed = (time.clock() - start)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;EXCEL Time used:&quot;</span>, elapsed)</span><br></pre></td></tr></table></figure>

<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">PKL</span> Time used: <span class="number">0</span>.<span class="number">0913808</span></span><br><span class="line"><span class="attribute">CSV</span> Time used: <span class="number">0</span>.<span class="number">2128232</span></span><br><span class="line"><span class="attribute">EXCEL</span> Time used: <span class="number">10</span>.<span class="number">9964416</span></span><br></pre></td></tr></table></figure>
<p>pickle完美胜出。参考链接中有大佬的更详细的比拼。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/d857c0f472f4">https://www.jianshu.com/p/d857c0f472f4</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 个人博客搭建历程</title>
    <url>/2020/03/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p>参考知乎这个链接</p>
<p><a href="https://zhuanlan.zhihu.com/p/106166402">https://zhuanlan.zhihu.com/p/106166402</a></p>
<p>B站里up主Codesheep也有搭建视频</p>
<p><a href="https://www.bilibili.com/video/av44544186/">https://www.bilibili.com/video/av44544186/</a></p>
<h1 id="大体步骤"><a href="#大体步骤" class="headerlink" title="大体步骤"></a>大体步骤</h1><ol>
<li>安装 git</li>
<li>安装Node.js</li>
<li>在Node.js里安装Hexo</li>
<li>选取喜欢的主题套用修改</li>
</ol>
<h1 id="安装中碰到的问题-amp-解决方案"><a href="#安装中碰到的问题-amp-解决方案" class="headerlink" title="安装中碰到的问题&amp;解决方案"></a>安装中碰到的问题&amp;解决方案</h1><p><a href="https://blog.csdn.net/weixin_36401046/article/details/52940313">hexo d后 ERROR Deployer not found: git</a></p>
<p><a href="https://blog.csdn.net/weixin_45122120/article/details/91872691">解决git下载很慢的问题</a></p>
<p><a href="https://blog.csdn.net/qq_27093465/article/details/72954725?locationNum=6&fps=1">HEXO安装(Win7 64 bit )，遇到cmd报错：’hexo’ 不是内部或外部命令，也不是可运行的程序</a><br>(简单总结：需要配置hexo的环境变量)</p>
<p>Tips：</p>
<ol>
<li><p>把出现的错误代码直接复制到百度就可找到解决方法</p>
</li>
<li><p>在下载国外的一些工具时,可以考虑下载镜像,速度飞起</p>
</li>
</ol>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>创建新文件：</p>
<pre><code>hexo n &quot;新的文章名&quot;</code></pre><p>生成页面：</p>
<pre><code>hexo g </code></pre><p>在本地浏览器查看效果:</p>
<pre><code>hexo s</code></pre><p>部署到远端服务器:</p>
<pre><code>hexo d</code></pre><h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><p>另外发现更多的Hexo教程<br><a href="http://ijiaober.github.io/categories/hexo/">Hexo使用攻略</a></p>
<p><a href="https://blog.zhangruipeng.me/hexo-theme-icarus/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/">Icarus中文用户指南</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣1310子数组异或查询</title>
    <url>/2021/05/12/%E5%8A%9B%E6%89%A31310%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="力扣1310子数组异或查询"><a href="#力扣1310子数组异或查询" class="headerlink" title="力扣1310子数组异或查询"></a>力扣1310子数组异或查询</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</p>
<p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 queries 所有结果的数组。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8]<br>解释：<br>数组中元素的二进制表示形式是：<br>1 = 0001<br>3 = 0011<br>4 = 0100<br>8 = 1000<br>查询的 XOR 值为：<br>[0,1] = 1 xor 3 = 2<br>[1,2] = 3 xor 4 = 7<br>[0,3] = 1 xor 3 xor 4 xor 8 = 14<br>[3,3] = 8</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]<br>输出：[8,0,4,4]</p>
</blockquote>
<p><strong>提示：</strong></p>
<blockquote>
<p>1 &lt;= arr.length &lt;= 3 * 10^4<br>1 &lt;= arr[i] &lt;= 10^9<br>1 &lt;= queries.length &lt;= 3 * 10^4<br>queries[i].length == 2<br>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</p>
</blockquote>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray">https://leetcode-cn.com/problems/xor-queries-of-a-subarray</a></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>前缀和的思想。使用暴力法会超时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;XOR前缀和&quot;&quot;&quot;</span></span><br><span class="line">        pre = [<span class="number">0</span>]  <span class="comment"># 前缀数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            pre.append(arr[i] ^ pre[-<span class="number">1</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(pre[a] ^ pre[b + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<p>评论区<a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/comments/214199">神解答</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        acc = <span class="built_in">list</span>(accumulate([<span class="number">0</span>] + arr, xor))</span><br><span class="line">        <span class="keyword">return</span> [acc[a] ^ acc[b + <span class="number">1</span>] <span class="keyword">for</span> a, b <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣199二叉树的右视图</title>
    <url>/2021/05/08/%E5%8A%9B%E6%89%A3199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p>示例:</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">5</span>,null,<span class="number">4</span>]</span><br><span class="line">输出: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>            &lt;-<span class="comment">--</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>         &lt;-<span class="comment">--</span></span><br><span class="line"> \     \</span><br><span class="line">  <span class="number">5</span>     <span class="number">4</span>       &lt;-<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view">https://leetcode-cn.com/problems/binary-tree-right-side-view</a></p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>参考<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/comments/360687">甜姐的解答</a></p>
<blockquote>
<p>二、DFS<br>我们按照 「根结点 -&gt; 右子树 -&gt; 左子树」 的顺序访问， 就可以保证每层都是最先访问最右边的节点的。<br>（与先序遍历 「根结点 -&gt; 左子树 -&gt; 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (depth == res.size()) res.add(root.val);</span><br><span class="line">        dfs(root.right, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>面试高频</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣300.最长递增子序列</title>
    <url>/2021/04/28/%E5%8A%9B%E6%89%A3300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：nums = [0,1,0,3,2,3]<br>输出：4</p>
</blockquote>
<p>示例 3：</p>
<blockquote>
<p>输入：nums = [7,7,7,7,7,7,7]<br>输出：1</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p>
</blockquote>
<p>进阶：</p>
<blockquote>
<p>你可以设计时间复杂度为 O(n2) 的解决方案吗？<br>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p>
</blockquote>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>引用 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/comments/284831">甜姨的评论</a></p>
<blockquote>
<p>相当于维护一个结果数组，如果当前元素比结果数组的值都大的的话，就追加在结果数组后面（相当于递增序列长度加了1）；否则的话用当前元素覆盖掉第一个比它大的元素（这样做的话后续递增序列才有可能更长，即使并没有更长，这个覆盖操作也并没有副作用哈，当然这个覆盖操作可能会让最终的结果数组值并不是最终的递增序列值，这无所谓）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = Arrays.binarySearch(res, <span class="number">0</span>, len, num);</span><br><span class="line">            idx = idx &lt; <span class="number">0</span>? -idx - <span class="number">1</span>: idx;</span><br><span class="line">            res[idx] = num;</span><br><span class="line">            <span class="keyword">if</span> (idx == len) &#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里给出我的使用二分法API的Python版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            loc = bisect.bisect_left(res, x)</span><br><span class="line">            <span class="keyword">if</span> loc == <span class="built_in">len</span>(res):</span><br><span class="line">                res.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[loc] = x</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣377.组合综合Ⅳ</title>
    <url>/2021/04/24/%E5%8A%9B%E6%89%A3377-%E7%BB%84%E5%90%88%E7%BB%BC%E5%90%88%E2%85%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">target</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">9</span>], <span class="attr">target</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span> &lt;= nums.length &lt;= <span class="number">200</span></span><br><span class="line"><span class="attribute">1</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="attribute">nums</span> 中的所有元素 互不相同</span><br><span class="line"><span class="attribute">1</span> &lt;= target &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/combination-sum-iv">https://leetcode-cn.com/problems/combination-sum-iv</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>递归。加上lru_cache后不会超时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.nums = nums</span><br><span class="line">        <span class="keyword">return</span> self.recur(target)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @lru_cache(<span class="params"><span class="number">1000</span> * <span class="number">1000</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">self, target</span>):</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.nums:</span><br><span class="line">            <span class="keyword">if</span> x &lt;= target:</span><br><span class="line">                ret += self.recur(target - x)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<p>动态规划</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x &lt;= i:</span><br><span class="line">                    dp[i] += dp[i - x]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣403.青蛙过河</title>
    <url>/2021/04/29/%E5%8A%9B%E6%89%A3403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://pic.leetcode-cn.com/1619656977-DEvDOg-src=http___5b0988e595225.cdn.sohucs.com_images_20200508_327f15985a51404bb648f2f8e518045e.jpeg&refer=http___5b0988e595225.cdn.sohucs.jpeg" alt=""></p>
<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>
<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>
<p>如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p>示例 1：</p>
<blockquote>
<p>输入：stones = [0,1,3,5,6,8,12,17]<br>输出：true<br>解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：stones = [0,1,2,3,4,8,9,11]<br>输出：false<br>解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</p>
</blockquote>
<p>提示：</p>
<blockquote>
<p>2 &lt;= stones.length &lt;= 2000<br>0 &lt;= stones[i] &lt;= 231 - 1<br>stones[0] == 0</p>
</blockquote>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/frog-jump">https://leetcode-cn.com/problems/frog-jump</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>用户 <a href="https://leetcode-cn.com/problems/frog-jump/solution/python-ji-yi-hua-hui-su-by-bryannliu-dgd0/">bryannliu</a> 的解答：</p>
<blockquote>
<p>这题和 55. 跳跃游戏 有点像，但是55 满足贪心选择性，所以直接用贪心算法做，这道题目因为有多种走法，所以得一个个试，用记忆化递归来做比较合适。</p>
<p>因为每次有三种走法，要尝试每种可能，肯定有重复计算，所以加上备忘录。</p>
<ol>
<li>状态定义和参数：s(i, step) 表示当前是第i块时候，通过step步过来的，</li>
<li>决策和状态转移：接下来就是根据走的步数做状态变换，这里状态变换只有三种 step-1, step, step + 1, 尝试每种可能的走法，看能不能走到最后一块。</li>
</ol>
</blockquote>
<p>我这里的 recur(start, k) 中的 start 表示 stones数组顺序下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCross</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="literal">None</span></span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">start, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= n - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> stones[start] + k - <span class="number">1</span> == stones[i]:  <span class="comment"># 往后遍历找到 能以 k-1 步跳到的石子</span></span><br><span class="line">                    <span class="keyword">if</span> recur(i, k - <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> stones[start] + k == stones[i]:  <span class="comment"># 往后遍历找到 能以 k 步跳到的石子</span></span><br><span class="line">                    <span class="keyword">if</span> recur(i, k): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> stones[start] + k + <span class="number">1</span> == stones[i]:  <span class="comment"># 往后遍历找到 能以 k+1 步跳到的石子</span></span><br><span class="line">                    <span class="keyword">if</span> recur(i, k + <span class="number">1</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> stones[start] + k + <span class="number">1</span> &lt; stones[i]: <span class="keyword">break</span>  <span class="comment"># 因stones的单调性 提早结束遍历</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣69.x的平方根</title>
    <url>/2021/04/23/%E5%8A%9B%E6%89%A369-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 4</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: 8</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">说明: 8 的平方根是 2.82842..., </span></span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<p>链接：</p>
<p><a href="https://leetcode-cn.com/problems/sqrtx/">https://leetcode-cn.com/problems/sqrtx/</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分法是符合计算机思想的解法。</p>
<p>二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 bit 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        small = <span class="number">1</span></span><br><span class="line">        big = x</span><br><span class="line">        <span class="keyword">while</span> big - small &gt; <span class="number">1</span>:</span><br><span class="line">            bit = (small + big) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> bit ** <span class="number">2</span> == x:</span><br><span class="line">                <span class="keyword">return</span> bit</span><br><span class="line">            <span class="keyword">elif</span> bit ** <span class="number">2</span> &lt; x:</span><br><span class="line">                small = bit</span><br><span class="line">            <span class="keyword">elif</span> bit ** <span class="number">2</span> &gt; x:</span><br><span class="line">                big = bit</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(small)</span><br></pre></td></tr></table></figure>

<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>这个题解说的比较好：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/">https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/</a></p>
<p>该方法比较适合机器学习背景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">while</span> r * r &gt; x:</span><br><span class="line">            r = (r + x / r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(r)</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣938.二叉搜索树的范围和</title>
    <url>/2021/04/27/%E5%8A%9B%E6%89%A3938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定二叉搜索树的根结点 root，返回值位于范围 <code>[low, high]</code> 之间的所有结点的值的和。</p>
<p>示例 1：</p>
<p><img src="images/leetcode/938bst1.jpg" alt="二叉搜索树1"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="literal">null</span>,<span class="number">18</span>], <span class="attr">low</span> = <span class="number">7</span>, <span class="attr">high</span> = <span class="number">15</span></span><br><span class="line">输出：<span class="number">32</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<p><img src="images/leetcode/938bst2.jpg" alt="二叉搜索树2"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入：<span class="attr">root</span> = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">6</span>], <span class="attr">low</span> = <span class="number">6</span>, <span class="attr">high</span> = <span class="number">10</span></span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">树中节点数目在范围 <span class="literal">[<span class="number">1</span>, <span class="number">2</span> <span class="operator">*</span> <span class="number">104</span>]</span> 内</span><br><span class="line"><span class="number">1</span> &lt;= <span class="module-access"><span class="module"><span class="identifier">Node</span>.</span></span><span class="keyword">val</span> &lt;= <span class="number">105</span></span><br><span class="line"><span class="number">1</span> &lt;= low &lt;= high &lt;= <span class="number">105</span></span><br><span class="line">所有 <span class="module-access"><span class="module"><span class="identifier">Node</span>.</span></span><span class="keyword">val</span> 互不相同</span><br></pre></td></tr></table></figure>

<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/range-sum-of-bst">https://leetcode-cn.com/problems/range-sum-of-bst</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>一道简单题，中序遍历递归即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftVal = rangeSumBST(root.left, low, high);</span><br><span class="line">        <span class="keyword">int</span> midVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) midVal = root.val;</span><br><span class="line">        <span class="keyword">int</span> rightVal = rangeSumBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> leftVal + midVal + rightVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>字节面试题——输出化学式中每个原子的个数</title>
    <url>/2021/09/01/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E8%BE%93%E5%87%BA%E5%8C%96%E5%AD%A6%E5%BC%8F%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%8E%9F%E5%AD%90%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>2021.8.31 某同学的字节一面手撕算法题</p>
<p>给出类似于 <code>HM2(H2ON3A)3N2</code> 这样的类化学表达式</p>
<p>输出每个原子的个数</p>
<p>看起来有点意思</p>
<p>思路：</p>
<p>遇到左括号亚栈 有括号弹出栈</p>
<p>栈中存放固定大小为元素总数的数组，其记录每个元素的出现次数</p>
<p>同时主要到字母后面与右括号的数字，讲栈顶记录的出现次数与其相乘即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写上 所有 化学元素和 原子序数的对应 。这里比较懒先写几个用得到的</span></span><br><span class="line">DIC = &#123;</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;He&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;Li&#x27;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;O&#x27;</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="string">&#x27;S&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="string">&#x27;Al&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="string">&#x27;Cu&#x27;</span>: <span class="number">29</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RE_DIC = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;H&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;He&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;Li&#x27;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">    <span class="number">15</span>: <span class="string">&#x27;S&#x27;</span>,</span><br><span class="line">    <span class="number">12</span>: <span class="string">&#x27;Al&#x27;</span>,</span><br><span class="line">    <span class="number">29</span>: <span class="string">&#x27;Cu&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">s</span>):</span></span><br><span class="line">    stack = [[<span class="number">0</span>] * <span class="number">100</span>]  <span class="comment"># 化学元素先设定一百个吧。每个栈帧是个数组 数组按照元素顺序存放着元素的出现次数</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> idx, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">        <span class="keyword">if</span> item.isupper(): <span class="comment"># 化学元素名字总是一个大写字母开头后面都是小写字母</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 支持多字符的元素，识别出类似于 Al Cu 这样的元素</span></span><br><span class="line">            end = idx + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> end &lt;= n - <span class="number">1</span> <span class="keyword">and</span> s[end].islower():</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            name = s[idx:end]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录右下缀 ,如 读出 Al2 中数字 2</span></span><br><span class="line">            times = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> end &lt;= n - <span class="number">1</span> <span class="keyword">and</span> s[end].isdecimal():</span><br><span class="line">                times = <span class="built_in">int</span>(s[end])</span><br><span class="line">            stack[-<span class="number">1</span>][DIC[name]] += times</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&#x27;(&#x27;</span>: <span class="comment"># 压栈</span></span><br><span class="line">            stack.append([<span class="number">0</span>] * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&#x27;)&#x27;</span>: <span class="comment"># 出栈</span></span><br><span class="line">            times = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> idx != n - <span class="number">1</span> <span class="keyword">and</span> s[idx + <span class="number">1</span>].isdecimal():  <span class="comment"># 如果 ) 后面是数字 要加倍</span></span><br><span class="line">                times = <span class="built_in">int</span>(s[idx + <span class="number">1</span>])</span><br><span class="line">            popped = stack.pop()</span><br><span class="line">            <span class="comment"># 把弹出的信息，合并到栈顶中去</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(popped)):</span><br><span class="line">                stack[-<span class="number">1</span>][i] += popped[i] * times</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># s = &quot;Al2(SO4)3&quot;</span></span><br><span class="line">    s = <span class="string">&quot;Cu2(OH)2CO3&quot;</span></span><br><span class="line">    ret = solve(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">if</span> ret[<span class="number">0</span>][i] != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;原子<span class="subst">&#123;RE_DIC[i]&#125;</span> : <span class="subst">&#123;ret[<span class="number">0</span>][i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">原子H : 2</span><br><span class="line">原子C : 1</span><br><span class="line">原子O : 5</span><br><span class="line">原子Cu : 2</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
        <tag>栈</tag>
        <tag>数据结构与算法</tag>
        <tag>笔试面试</tag>
      </tags>
  </entry>
  <entry>
    <title>实用python小工具--函数运行时间装饰器</title>
    <url>/2021/04/23/%E5%AE%9E%E7%94%A8python%E5%B0%8F%E5%B7%A5%E5%85%B7-%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>装饰器定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">def CalculateTime(a_func):</span><br><span class="line">    def wrapTheFunction():</span><br><span class="line">        start &#x3D; time.time()</span><br><span class="line">        a_func()</span><br><span class="line">        cost &#x3D; time.time() - start</span><br><span class="line">        print(f&quot;Function \&quot;&#123;a_func.__name__&#125;\&quot; cost : &#123;cost&#125; second(s).&quot;)</span><br><span class="line">    return wrapTheFunction</span><br></pre></td></tr></table></figure>

<p>测试部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CalculateTime</span><br><span class="line">def func():</span><br><span class="line">    s &#x3D; 0</span><br><span class="line">    for i in range(10 ** 7):</span><br><span class="line">        s +&#x3D; 1</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    func()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="number">10000000</span></span><br><span class="line"><span class="keyword">Function</span> <span class="title">&quot;func&quot;</span> cost : 1.7449958324432373 <span class="type">second</span>(s).</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>建立打印力扣(Leetcode)中的二叉树-java</title>
    <url>/2021/04/27/%E5%BB%BA%E7%AB%8B%E6%89%93%E5%8D%B0%E5%8A%9B%E6%89%A3-Leetcode-%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-java/</url>
    <content><![CDATA[<h1 id="建立打印LeetCode中的二叉树"><a href="#建立打印LeetCode中的二叉树" class="headerlink" title="建立打印LeetCode中的二叉树"></a>建立打印LeetCode中的二叉树</h1><p>在刷力扣题时遇到二叉树的问题时，建树较为麻烦，打印树更加是不方便。</p>
<p>因为力扣中二叉树定义多为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再增加建树的成员方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatABitTree</span><span class="params">(Integer[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 得用队列</span></span><br><span class="line">    <span class="comment">// 根结点的处理</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line">    queue.offer(node);</span><br><span class="line"></span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ) &#123;</span><br><span class="line">        temp = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> temp != <span class="keyword">null</span>;</span><br><span class="line">            temp.left = <span class="keyword">new</span> TreeNode(nums[i++]);</span><br><span class="line">            queue.offer(temp.left);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums.length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> temp != <span class="keyword">null</span>;</span><br><span class="line">            temp.right = <span class="keyword">new</span> TreeNode(nums[i++]);</span><br><span class="line">            queue.offer(temp.right);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>参考 StackOverflow中<a href="https://stackoverflow.com/questions/4965335/how-to-print-binary-tree-diagram/8948691#8948691">How to print binary tree diagram?</a>这个问答，再添加树的打印方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">toString</span><span class="params">(StringBuilder prefix, <span class="keyword">boolean</span> isTail, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right.toString(<span class="keyword">new</span> StringBuilder().append(prefix).append(isTail ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), <span class="keyword">false</span>, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(prefix).append(isTail ? <span class="string">&quot;└── &quot;</span> : <span class="string">&quot;┌── &quot;</span>).append(val).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left.toString(<span class="keyword">new</span> StringBuilder().append(prefix).append(isTail ? <span class="string">&quot;    &quot;</span> : <span class="string">&quot;│   &quot;</span>), <span class="keyword">true</span>, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.toString(<span class="keyword">new</span> StringBuilder(), <span class="keyword">true</span>, <span class="keyword">new</span> StringBuilder()).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>使用以下测试函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeNode treeNode = TreeNode.creatABitTree(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">                <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得的测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│       ┌── 6</span><br><span class="line">│   ┌── 2</span><br><span class="line">│   │   └── 5</span><br><span class="line">└── 0</span><br><span class="line">    │   ┌── 4</span><br><span class="line">    └── 1</span><br><span class="line">        └── 3</span><br></pre></td></tr></table></figure>


<h1 id="完整的TreeNode类"><a href="#完整的TreeNode类" class="headerlink" title="完整的TreeNode类"></a>完整的TreeNode类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * create time: 2021/3/9 上午 10:01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DownUpZ</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 不选择 int[] 原因是 int 无法表示空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">creatABitTree</span><span class="params">(Integer[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span> || nums[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">// 得用队列</span></span><br><span class="line">        <span class="comment">// 根结点的处理</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[<span class="number">0</span>]);</span><br><span class="line">        queue.offer(node);</span><br><span class="line"></span><br><span class="line">        TreeNode temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ) &#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">assert</span> temp != <span class="keyword">null</span>;</span><br><span class="line">                temp.left = <span class="keyword">new</span> TreeNode(nums[i++]);</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= nums.length)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">assert</span> temp != <span class="keyword">null</span>;</span><br><span class="line">                temp.right = <span class="keyword">new</span> TreeNode(nums[i++]);</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">toString</span><span class="params">(StringBuilder prefix, <span class="keyword">boolean</span> isTail, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            right.toString(<span class="keyword">new</span> StringBuilder().append(prefix).append(isTail ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), <span class="keyword">false</span>, sb);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(prefix).append(isTail ? <span class="string">&quot;└── &quot;</span> : <span class="string">&quot;┌── &quot;</span>).append(val).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            left.toString(<span class="keyword">new</span> StringBuilder().append(prefix).append(isTail ? <span class="string">&quot;    &quot;</span> : <span class="string">&quot;│   &quot;</span>), <span class="keyword">true</span>, sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.toString(<span class="keyword">new</span> StringBuilder(), <span class="keyword">true</span>, <span class="keyword">new</span> StringBuilder()).toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>java</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>箱型图法处理异常</title>
    <url>/2021/04/23/%E7%AE%B1%E5%9E%8B%E5%9B%BE%E6%B3%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>箱型图介绍看链接：</p>
<p><a href="https://blog.csdn.net/oJiWuXuan/article/details/107815803">Python异常数据处理——箱型图分析</a></p>
<p>一下Python是使用箱型图找到异常值并用线性插值把剔除异常后的缺失填充上。</p>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wash_data</span>(<span class="params">df: pd.DataFrame</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;箱型图法&quot;&quot;&quot;</span></span><br><span class="line">    q1 = df.quantile(<span class="number">0.25</span>)</span><br><span class="line">    q3 = df.quantile(<span class="number">0.75</span>)</span><br><span class="line">    iqr = q3 - q1</span><br><span class="line">    mi = q1 - <span class="number">1.5</span> * iqr</span><br><span class="line">    ma = q3 + <span class="number">1.5</span> * iqr</span><br><span class="line">    <span class="comment"># error = df[(df &lt; mi) | (df &gt; ma)]</span></span><br><span class="line">    data_c = df[(df &gt;= mi) &amp; (df &lt;= ma)]</span><br><span class="line">    <span class="keyword">return</span> data_c.interpolate().bfill()  <span class="comment"># 线性插值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    df = pd.DataFrame(data=np.random.rand(<span class="number">10</span>, <span class="number">2</span>))</span><br><span class="line">    df[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">    df[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">99</span></span><br><span class="line">    <span class="built_in">print</span>(df)</span><br><span class="line">    washedDf = wash_data(df)</span><br><span class="line">    <span class="built_in">print</span>(washedDf)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">            <span class="number">0</span>         <span class="number">1</span></span><br><span class="line"><span class="number">0</span>    <span class="number">0.385158</span>  <span class="number">0.469756</span></span><br><span class="line"><span class="number">1</span>  <span class="number">100.000000</span>  <span class="number">0.090029</span></span><br><span class="line"><span class="number">2</span>   <span class="number">99.000000</span>  <span class="number">0.807008</span></span><br><span class="line"><span class="number">3</span>    <span class="number">0.832849</span>  <span class="number">0.672141</span></span><br><span class="line"><span class="number">4</span>    <span class="number">0.965382</span>  <span class="number">0.847540</span></span><br><span class="line"><span class="number">5</span>    <span class="number">0.275084</span>  <span class="number">0.003218</span></span><br><span class="line"><span class="number">6</span>    <span class="number">0.366026</span>  <span class="number">0.211611</span></span><br><span class="line"><span class="number">7</span>    <span class="number">0.462773</span>  <span class="number">0.226748</span></span><br><span class="line"><span class="number">8</span>    <span class="number">0.244522</span>  <span class="number">0.916068</span></span><br><span class="line"><span class="number">9</span>    <span class="number">0.906602</span>  <span class="number">0.029235</span></span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0.385158</span>  <span class="number">0.469756</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0.534389</span>  <span class="number">0.090029</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0.683619</span>  <span class="number">0.807008</span></span><br><span class="line"><span class="number">3</span>  <span class="number">0.832849</span>  <span class="number">0.672141</span></span><br><span class="line"><span class="number">4</span>  <span class="number">0.965382</span>  <span class="number">0.847540</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.275084</span>  <span class="number">0.003218</span></span><br><span class="line"><span class="number">6</span>  <span class="number">0.366026</span>  <span class="number">0.211611</span></span><br><span class="line"><span class="number">7</span>  <span class="number">0.462773</span>  <span class="number">0.226748</span></span><br><span class="line"><span class="number">8</span>  <span class="number">0.244522</span>  <span class="number">0.916068</span></span><br><span class="line"><span class="number">9</span>  <span class="number">0.906602</span>  <span class="number">0.029235</span></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>美团2021.8.15的一个笔试题</title>
    <url>/2021/08/15/%E7%BE%8E%E5%9B%A22021-8-15%E7%9A%84%E4%B8%80%E4%B8%AA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>参加美团笔试的其中一个笔试题，题干是以角色扮演类游戏为背景，计算角色对标靶的总攻击和。<br>没有记录下详细的题干，只有自己的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warrior</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, d, c2, c3, c4</span>):</span></span><br><span class="line">        self.INITIAL_ATTACK = a  <span class="comment"># 初始攻击力</span></span><br><span class="line">        self.MAX_ATTACK_BUFF_TIME = c2  <span class="comment"># 进攻buff 持续时间</span></span><br><span class="line">        self.MAX_AIM_DEFENCE = d  <span class="comment"># 目标最大防御力</span></span><br><span class="line">        self.MAX_DEFENCE_BUFF_TIME = c3  <span class="comment"># 减防buff持续时间</span></span><br><span class="line">        self.PERMANENCY_ATTACK_INCREASE = c4  <span class="comment"># 永久提升额</span></span><br><span class="line"></span><br><span class="line">        self.baseAttack = self.INITIAL_ATTACK  <span class="comment"># 基础攻击力</span></span><br><span class="line">        self.aimDefence = self.MAX_AIM_DEFENCE  <span class="comment"># 目标防御力</span></span><br><span class="line">        self.defenceBuffTime = <span class="number">0</span>  <span class="comment"># 减防buff剩余时间</span></span><br><span class="line">        self.attackBuffTimes = []  <span class="comment"># 攻击buff剩余时间</span></span><br><span class="line"></span><br><span class="line">        self.totalAttack = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 进攻</span></span><br><span class="line">        attack = (<span class="built_in">len</span>(self.attackBuffTimes) + <span class="number">1</span>) * self.baseAttack  <span class="comment"># 计算攻击力加成</span></span><br><span class="line"></span><br><span class="line">        defence = self.MAX_AIM_DEFENCE</span><br><span class="line">        <span class="keyword">if</span> self.defenceBuffTime &gt; <span class="number">0</span>:</span><br><span class="line">            defence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.totalAttack += <span class="built_in">max</span>(<span class="number">1</span>, attack - defence)</span><br><span class="line">        self.final()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 增加buff</span></span><br><span class="line">        self.attackBuffTimes.append(self.MAX_ATTACK_BUFF_TIME)</span><br><span class="line">        self.final()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do3</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 刷新减防</span></span><br><span class="line">        self.defenceBuffTime = self.MAX_DEFENCE_BUFF_TIME</span><br><span class="line">        self.final()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do4</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 增加永久攻击</span></span><br><span class="line">        self.baseAttack += self.PERMANENCY_ATTACK_INCREASE</span><br><span class="line">        self.final()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">final</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># buff结算</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> self.attackBuffTimes: self.attackBuffTimes.remove(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.attackBuffTimes)):</span><br><span class="line">            self.attackBuffTimes[i] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.defenceBuffTime != <span class="number">0</span>:</span><br><span class="line">            self.defenceBuffTime -= <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    d = <span class="number">3</span></span><br><span class="line">    c2 = <span class="number">6</span></span><br><span class="line">    c3 = <span class="number">6</span></span><br><span class="line">    c4 = <span class="number">2</span></span><br><span class="line">    opt = <span class="string">&quot;121341&quot;</span></span><br><span class="line">    warrior = Warrior(a, d, c2, c3, c4)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> opt:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            warrior.do1()</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">            warrior.do2()</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">            warrior.do3()</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">            warrior.do4()</span><br><span class="line">    <span class="built_in">print</span>(warrior.totalAttack)</span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#     try:</span></span><br><span class="line">    <span class="comment">#         n, a, d, c2, c3, c4 = [int(i) for i in input().split()]</span></span><br><span class="line">    <span class="comment">#         opt = input()</span></span><br><span class="line">    <span class="comment">#         ans = solve(a, d, c2, c3, c4, opt)</span></span><br><span class="line">    <span class="comment">#         print(ans)</span></span><br><span class="line">    <span class="comment">#     except:</span></span><br><span class="line">    <span class="comment">#         break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>造个轮子——实现python中的lru_cache</title>
    <url>/2021/09/01/%E9%80%A0%E4%B8%AA%E8%BD%AE%E5%AD%90%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0python%E4%B8%AD%E7%9A%84lru-cache/</url>
    <content><![CDATA[<h1 id="力扣题"><a href="#力扣题" class="headerlink" title="力扣题"></a>力扣题</h1><p>首先看一道高频经典力扣题<a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>，题干不再赘述。直接放出我的题解</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, val=<span class="number">0</span>, prev=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.currentSize = <span class="number">0</span></span><br><span class="line">        self.dic = &#123;&#125;</span><br><span class="line">        self.head = ListNode()</span><br><span class="line">        self.tail = ListNode()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">            <span class="keyword">return</span> self.dic[key].val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.dic:  <span class="comment"># 存在不用考虑size</span></span><br><span class="line">            self.dic[key].val = value</span><br><span class="line">            self.move_to_end(key)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 不存在</span></span><br><span class="line">            <span class="keyword">if</span> self.currentSize == self.capacity:  <span class="comment"># 满了</span></span><br><span class="line">                self.delete(self.head.<span class="built_in">next</span>.key)</span><br><span class="line">                self.currentSize -= <span class="number">1</span></span><br><span class="line">            self.append(key, value)</span><br><span class="line">            self.currentSize += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span>(<span class="params">self, key, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        nodePrev = self.tail.prev</span><br><span class="line">        nodeNext = self.tail</span><br><span class="line"></span><br><span class="line">        node = ListNode(key, value, nodePrev, nodeNext)</span><br><span class="line">        self.dic[key] = node</span><br><span class="line"></span><br><span class="line">        nodePrev.<span class="built_in">next</span> = node</span><br><span class="line">        nodeNext.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, key</span>) -&gt; ListNode:</span></span><br><span class="line">        node = self.dic.pop(key)</span><br><span class="line"></span><br><span class="line">        nodePrev = node.prev</span><br><span class="line">        nodeNext = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        nodePrev.<span class="built_in">next</span> = nodeNext</span><br><span class="line">        nodeNext.prev = nodePrev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_end</span>(<span class="params">self, key</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        popped = self.delete(key)</span><br><span class="line">        self.append(popped.key, popped.val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>嗯。hashmap + 双向链表 搞定！</p>
<h1 id="Python装饰器"><a href="#Python装饰器" class="headerlink" title="Python装饰器"></a>Python装饰器</h1><p>既然LRU类都整出来了，自己可以自己实现 python functools里的 @lru_cache呀。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己定义一个lru装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lru_cache</span>(<span class="params">size: [<span class="built_in">int</span>, <span class="literal">None</span>] = <span class="number">128</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    size 如果是 None, 则缓存大小不受限制。但是递归深度python 是有限制的，</span></span><br><span class="line"><span class="string">    使用这个装饰器并不能解决所有动态规划问题</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        size = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lru_cache_decorator</span>(<span class="params">f</span>):</span></span><br><span class="line">        lru = LRUCache(size)</span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(<span class="params">f</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            cached = lru.get(args)</span><br><span class="line">            <span class="keyword">if</span> cached == -<span class="number">1</span>:</span><br><span class="line">                ret = f(*args, **kwargs)</span><br><span class="line">                lru.put(args, ret)</span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> cached</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lru_cache_decorator</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@lru_cache()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feb</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> feb(n - <span class="number">1</span>) + feb(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(feb(<span class="number">1000</span>)) <span class="comment"># 跑起来飞快 去掉 装饰器慢如乌龟</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></p>
<p><a href="https://www.runoob.com/w3cnote/python-func-decorators.html">Python 函数装饰器 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>python</tag>
        <tag>面试高频</tag>
        <tag>记忆化搜索</tag>
        <tag>数据结构与算法</tag>
        <tag>笔试面试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣679.24点游戏</title>
    <url>/2021/09/10/%E5%8A%9B%E6%89%A3679-24%E7%82%B9%E6%B8%B8%E6%88%8F-md/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p>
<p>示例 1:</p>
<p>输入: [4, 1, 8, 7]<br>输出: True<br>解释: (8-4) * (7-1) = 24</p>
<p>示例 2:</p>
<p>输入: [1, 2, 1, 2]<br>输出: False<br>注意:</p>
<p>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</p>
<p>链接：<a href="https://leetcode-cn.com/problems/24-game">https://leetcode-cn.com/problems/24-game</a></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><p>递归暴力搜寻。。。</p>
<p><code>judgePoint24(cards)</code>函数意义为 cards 数组 是否满足 24 点。 </p>
<p>存在递归关系 ， 从cards中随便挑选两个进行任何运算，把运算出来的结果放回cards，调用递归算下去即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span>(<span class="params">self, cards: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span> <span class="comment"># 支持 n 个 卡的24点游戏</span></span><br><span class="line">        size = <span class="built_in">len</span>(cards)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cards) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(cards[<span class="number">0</span>] - <span class="number">24</span>) &lt; <span class="number">0.0001</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size): <span class="comment">#  挑选两个数</span></span><br><span class="line">                <span class="keyword">if</span> i == j: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> sign <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                    newCards = cards[:]</span><br><span class="line">                    newCards.remove(cards[i])</span><br><span class="line">                    newCards.remove(cards[j]) <span class="comment"># 取出来</span></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        newCards.append(<span class="built_in">eval</span>(<span class="string">&quot;%f%s%f&quot;</span> % (cards[i], sign, cards[j]))) <span class="comment"># 加减乘除算一下放回去</span></span><br><span class="line">                        <span class="keyword">if</span> self.judgePoint24(newCards): <span class="comment"># 递归调用</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, cards, formulas</span>):</span></span><br><span class="line">        size = <span class="built_in">len</span>(cards)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cards) == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">abs</span>(cards[<span class="number">0</span>] - <span class="number">24</span>) &lt; <span class="number">0.0001</span></span><br><span class="line">            <span class="keyword">if</span> ans:</span><br><span class="line">                <span class="built_in">print</span>(formulas[<span class="number">0</span>] + <span class="string">&quot; = 24&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="keyword">if</span> i == j: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> sign <span class="keyword">in</span> <span class="string">&quot;+-*/&quot;</span>:</span><br><span class="line">                    newCards = cards[:]</span><br><span class="line">                    newCards.remove(cards[i])</span><br><span class="line">                    newCards.remove(cards[j])</span><br><span class="line">                    newFormulas = formulas[:]</span><br><span class="line">                    newFormulas.remove(formulas[i])</span><br><span class="line">                    newFormulas.remove(formulas[j])</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        formula = <span class="string">&quot;%f%s%f&quot;</span> % (cards[i], sign, cards[j])</span><br><span class="line">                        newCards.append(<span class="built_in">eval</span>(formula))</span><br><span class="line">                        newFormulas.append(<span class="string">&#x27;(&#x27;</span> + formulas[i] + sign + formulas[j] + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                        <span class="keyword">if</span> self.dfs(newCards, newFormulas):</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judgePoint24</span>(<span class="params">self, cards: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(cards, <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, cards)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sol = Solution()</span><br><span class="line">    <span class="comment"># cards = [4, 1, 8, 7]</span></span><br><span class="line">    <span class="comment"># cards = [1, 2, 1, 2]</span></span><br><span class="line">    cards = [<span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">    ret = sol.judgePoint24(cards)</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (6/(1-(6/8))) = 24</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>力扣</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字节第四批笔试贪心题</title>
    <url>/2021/09/12/%E5%AD%97%E8%8A%82%E7%AC%AC%E5%9B%9B%E6%89%B9%E7%AC%94%E8%AF%95%E8%B4%AA%E5%BF%83%E9%A2%98/</url>
    <content><![CDATA[<p>2021-09-12字节后端岗位笔试第四题</p>
<p>给出一组数</p>
<p>累计选中和不能小于0 ，求最多选择的个数</p>
<p>类似于 <a href="https://leetcode-cn.com/problems/p0NxJO/">https://leetcode-cn.com/problems/p0NxJO/</a></p>
<p><img src="images/carbon21091201.png" alt=""></p>
<p><img src="images/carbon21091202.png" alt=""></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>笔试面试</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
